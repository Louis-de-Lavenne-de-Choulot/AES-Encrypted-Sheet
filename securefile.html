<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure File Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <style>
        /* General Reset and Base Styling */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Roboto', Arial, sans-serif;
            color: #333;
            background-color: #f4f4f9;
            line-height: 1.6;
        }

        .container {
            padding: 20px;
        }

        /* Navigation Bar */
        .nav {
            background: #4CAF50;
            color: #fff;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav button {
            background: #fff;
            color: #4CAF50;
            border: none;
            padding: 0.5rem 1.5rem;
            margin-right: 1rem;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s, color 0.3s;
        }

        .nav button:hover {
            background: #4CAF50;
            color: #fff;
        }

        /* Views */
        #homeView,
        #editorView {
            display: none;
        }

        .active {
            display: block !important;
        }

        /* Home View */
        #homeView h2 {
            margin-bottom: 20px;
            font-size: 2rem;
            color: #4CAF50;
        }

        #homeView label {
            font-weight: bold;
        }

        #homeView input {
            padding: 10px;
            width: 100%;
            margin-top: 5px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 1rem;
        }

        #homeView button {
            background: #4CAF50;
            color: #fff;
            border: none;
            padding: 0.75rem 1.5rem;
            margin-right: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        #homeView button:hover {
            background: #45a049;
        }

        /* Editor View */
        .editor-toolbar {
            display: flex;
            gap: 10px;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-btn {
            background: #007BFF;
            color: #fff;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .dropdown-btn:hover {
            background: #0056b3;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 150px;
            box-shadow: 0px 8px 16px rgba(0, 0, 0, 0.2);
            z-index: 1;
            border-radius: 5px;
        }

        .dropdown-content button {
            color: #333;
            padding: 10px 15px;
            text-align: left;
            text-decoration: none;
            display: block;
            border: none;
            background: none;
            cursor: pointer;
            width: 100%;
        }

        .dropdown-content button:hover {
            background-color: #f1f1f1;
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }



        /* EDITOR MAIN STYLE */

        .sheet-tabs {
            display: flex;
            gap: 5px;
            padding: 5px;
            background: #f0f0f0;
        }

        .sheet-tab {
            padding: 5px 15px;
            cursor: pointer;
            border: 1px solid #ccc;
        }

        .sheet-tab.active {
            background: #fff;
            border-bottom: none;
        }

        .excel-grid {
            display: grid;
            grid-template-columns: 40px repeat(100, 100px);
            grid-template-rows: 30px repeat(1000, 30px);
        }

        .cell {
            border: 1px solid #ccc;
            padding: 5px;
            height: 30px;
            overflow: hidden;
            white-space: nowrap;
        }

        .cell.header {
            background: #f0f0f0;
            font-weight: bold;
            text-align: center;
        }

        .cell.row-header {
            background: #f0f0f0;
            font-weight: bold;
            text-align: center;
            position: sticky;
            left: 0;
        }

        .cell.selected {
            background-color: #cce5ff;
            border: 2px solid #007bff;
        }

        .cell.hidden-content {
            color: inherit;
            /* Keep the default text color */
            font-weight: bold;
            /* Optional: Emphasize hidden content */
        }
    </style>

































    <style>
        body {
            font-family: Calibri, Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        .menu-bar {
            display: flex;
            align-items: center;
            background-color: #f3f4f6;
            border-bottom: 1px solid #d1d5db;
            padding: 0 10px;
            overflow-x: auto;
        }

        .menu-bar .tab {
            font-size: 14px;
            font-weight: 500;
            color: #1f2937;
            padding: 10px 15px;
            cursor: pointer;
            white-space: nowrap;
            transition: background-color 0.3s;
        }

        .menu-bar .tab:hover {
            background-color: #e5e7eb;
            border-radius: 4px;
        }

        .menu-bar .tab.active {
            background-color: #e5e7eb;
            border-radius: 4px;
        }

        .tool-panel {
            display: flex;
            padding: 6px;
            background-color: white;
            border-bottom: 1px solid #d1d5db;
            overflow-x: auto;
        }

        .tool-group {
            border-right: 1px solid #d1d5db;
            padding-right: 20px;
            margin-right: 20px;
            min-width: fit-content;
        }

        .tool-group:last-child {
            border-right: none;
            margin-right: 0;
        }

        .tool {
            display: flex;
            align-items: center;
            font-size: 12px;
            margin-bottom: 10px;
            gap: 5px;
        }

        .tool .icon {
            width: 20px;
            height: 20px;
            border: none;
            margin-right: 5px;
            background-color: #e5e7eb;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            border-radius: 3px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .tool .icon:hover {
            background-color: #d1d5db;
        }

        .tool .label {
            color: #374151;
            cursor: pointer;
        }

        .tool input[type="text"],
        .tool select {
            font-size: 12px;
            padding: 5px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            min-width: 100px;
        }

        .tool input[type="number"] {
            width: 60px;
            font-size: 12px;
            padding: 5px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
        }

        .tool .button {
            background-color: #e5e7eb;
            border: 1px solid #d1d5db;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .tool .button:hover {
            background-color: #d1d5db;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: white;
            min-width: 160px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            z-index: 1;
            border-radius: 4px;
            border: 1px solid #d1d5db;
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        .dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
        }

        .dropdown-item:hover {
            background-color: #f3f4f6;
        }

        .group-title {
            font-size: 11px;
            color: #6b7280;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .separator {
            height: 1px;
            background-color: #d1d5db;
            margin: 5px 0;
        }

        .submenu-indicator {
            margin-left: auto;
            font-size: 10px;
        }

        .color-picker {
            display: grid;
            grid-template-columns: repeat(5, 20px);
            gap: 2px;
        }

        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 2px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <!-- Navigation Bar -->
    <div class="nav">
        <div>Secure File Editor</div>
        <div>
            <button onclick="showView('home')">Home</button>
            <button onclick="showView('editor')">Editor</button>
        </div>
    </div>

    <!-- Home View -->
    <div id="homeView" class="container active">
        <h2>Welcome to Secure File Editor</h2>
        <div style="margin-bottom: 20px;">
            <label for="masterPassword">Master Password:</label>
            <input type="password" id="masterPassword" placeholder="Enter Master Password">
        </div>
        <div>
            <button onclick="scanUSB()">Scan for SecureKeys</button>
            <button onclick="createNewSecureFile()">Create New Secure File</button>
            <button onclick="openSecureFile()">Open Secure File</button>
        </div>
    </div>

    <!-- Editor View -->
    <div id="editorView" class="container">

        <!-- Menu Bar -->
        <div class="menu-bar">
            <!-- <div class="tab">Fichier</div> -->
            <div class="tab active">Accueil</div>
            <!-- <div class="tab">Insertion</div>
            <div class="tab">Dessin</div>
            <div class="tab">Mise en page</div>
            <div class="tab">Formules</div>
            <div class="tab">Données</div>
            <div class="tab">Révision</div>
            <div class="tab">Affichage</div> -->
        </div>

        <!-- Tool Panel -->
        <div class="tool-panel">
            <!-- Group 1: Presse-papiers -->
            <div class="tool-group">
                <div class="group-title">spécial</div>
                <div class="tool dropdown">
                    <button title="" type="button" onclick="toggleHiddenCell()">Cacher contenu</button>
                </div>
                <div class="group-title">Presse-papiers</div>
                <div class="tool dropdown">
                    <button class="icon" title="" type="button">📋</button>
                    <div class="label">Coller</div>
                    <div class="dropdown-content">
                        <div class="dropdown-item">Coller</div>
                        <div class="dropdown-item">Coller les valeurs</div>
                        <div class="dropdown-item">Coller les formules</div>
                        <div class="dropdown-item">Coller en tant qu'image</div>
                        <div class="dropdown-item">Collage spécial...</div>
                    </div>
                </div>
                <div class="tool">
                    <button class="icon" title="" type="button">✂</button>
                    <div class="label">Couper</div>
                </div>
                <div class="tool">
                    <button class="icon" title="" type="button">📄</button>
                    <div class="label">Copier</div>
                </div>
            </div>

            <!-- Group 2: Police -->
            <div class="tool-group">
                <div class="group-title">Police</div>
                <div class="tool">
                    <select onchange="setFontFamily(this.value)">
                        <option>Calibri</option>
                        <option>Arial</option>
                        <option>Times New Roman</option>
                        <option>Helvetica</option>
                        <option>Verdana</option>
                    </select>
                    <input id="fontSizeInput" type="number" value="14" oninput="setFontSize()">
                </div>
                <div class="tool">
                    <button class="icon" title="" type="button" style="font-weight: bold;"
                        onclick="toggleBold()">B</button>
                    <button class="icon" title="" type="button" style="font-style: italic;"
                        onclick="toggleItalic()">I</button>
                    <button class="icon" title="" type="button" style="text-decoration: underline;"
                        onclick="toggleUnderline()">S</button>
                </div>
                <div class="tool">
                    <button class="icon" title="" type="button"
                        onclick="document.getElementById('fontSizeInput').value= parseFloat(document.getElementById('fontSizeInput').value == '' ? 14 : document.getElementById('fontSizeInput').value) + 1; setFontSize()">A+</button>
                    <button class="icon" title="" type="button"
                        onclick="document.getElementById('fontSizeInput').value= parseFloat(document.getElementById('fontSizeInput').value == '' ? 14 : document.getElementById('fontSizeInput').value) - 1; setFontSize()">A-</button>
                    <button class="icon" title="" type="button" onclick="toggleUpper()">Aa</button>
                </div>
                <div class="tool">
                    <div class="color-picker">
                        <button class="color-swatch" title="" type="button" onclick="setTextColor('#000000')"
                            style="background-color: #000000;">
                        </button>
                        <button class="color-swatch" title="" type="button" onclick="setTextColor('#FF0000')"
                            style="background-color: #FF0000;">
                        </button>
                        <button class="color-swatch" title="" type="button" onclick="setTextColor('#00FF00')"
                            style="background-color: #00FF00;">
                        </button>
                        <button class="color-swatch" title="" type="button" onclick="setTextColor('#0000FF')"
                            style="background-color: #0000FF;">
                        </button>
                        <button class="color-swatch" title="" type="button" onclick="setTextColor('#FFFF00')"
                            style="background-color: #FFFF00;">
                        </button>
                    </div>
                </div>
            </div>

            <!-- Group 3: Alignment -->
            <div class="tool-group">
                <div class="group-title">Alignement</div>
                <div class="tool">
                    <button class="icon" title="" type="button" onclick="setTextAlign('justify')">⇐</button>
                    <button class="icon" title="" type="button" onclick="setTextAlign('center')">⇔</button>
                    <button class="icon" title="" type="button" onclick="setTextAlign('right')">⇒</button>
                </div>
                <div class="tool">
                    <!-- <button class="icon" title="" type="button" onclick="setVerticalAlign('top')">⬆</button>
                    <button class="icon" title="" type="button" onclick="setVerticalAlign('middle')">⬇</button>
                    <button class="icon" title="" type="button" onclick="setVerticalAlign('bottom')">⬍</button> -->
                </div>
            </div>

            <!-- Group 4: Nombre -->
            <div class="tool-group">
                <div class="group-title">Nombre</div>
                <div class="tool">
                    <select onchange="setNumberFormat(this.value)">
                        <option value="general">Standard</option>
                        <option value="currency">Monétaire</option>
                        <option value="percentage">Pourcentage</option>
                        <option value="date">Date</option>
                        <option value="time">Heure</option>
                        <option value="number">Scientifique</option>
                        <option value="none">Texte</option>
                    </select>
                </div>
            </div>

            <!-- Group 5: Cellules -->
            <!-- <div class="tool-group">
                <div class="group-title">Cellules</div>
                <div class="tool dropdown">
                    <div class="label">Insérer</div>
                    <div class="dropdown-content">
                        <div class="dropdown-item">Insérer des cellules</div>
                        <div class="dropdown-item">Insérer des lignes</div>
                        <div class="dropdown-item">Insérer des colonnes</div>
                        <div class="dropdown-item">Insérer une feuille</div>
                    </div>
                </div>
                <div class="tool dropdown">
                    <div class="label">Supprimer</div>
                    <div class="dropdown-content">
                        <div class="dropdown-item">Supprimer des cellules</div>
                        <div class="dropdown-item">Supprimer des lignes</div>
                        <div class="dropdown-item">Supprimer des colonnes</div>
                        <div class="dropdown-item">Supprimer la feuille</div>
                    </div>
                </div>
                <div class="tool">
                    <div class="label">Format</div>
                </div>
            </div> -->

            <!-- Group 6: Styles -->
            <!-- <div class="tool-group">
                <div class="group-title">Styles</div>
                <div class="tool dropdown">
                    <div class="label">Mise en forme conditionnelle</div>
                    <div class="dropdown-content">
                        <div class="dropdown-item">Règles de mise en surbrillance</div>
                        <div class="dropdown-item">Règles des premières/dernières</div>
                        <div class="dropdown-item">Barres de données</div>
                        <div class="dropdown-item">Nuances de couleurs</div>
                        <div class="dropdown-item">Jeux d'icônes</div>
                    </div>
                </div>
                <div class="tool dropdown">
                    <div class="label">Format de tableau</div>
                    <div class="dropdown-content">
                        <div class="dropdown-item">Tableau simple</div>
                        <div class="dropdown-item">Tableau avec en-têtes</div>
                        <div class="dropdown-item">Tableau filtré</div>
                    </div>
                </div>
                <div class="tool dropdown">
                    <div class="label">Styles de cellules</div>
                    <div class="dropdown-content">
                        <div class="dropdown-item">Normal</div>
                        <div class="dropdown-item">Titre</div>
                        <div class="dropdown-item">Accentuation</div>
                        <div class="dropdown-item">Note</div>
                        <div class="dropdown-item">Avertissement</div>
                    </div>
                </div>
            </div> -->

            <!-- Group 7: Edition -->
            <!-- <div class="tool-group">
                <div class="group-title">Edition</div>
                <div class="tool">
                    <button class="icon" title="" type="button">🔍</button>
                    <div class="label">Rechercher</div>
                </div>
                <div class="tool dropdown">
                    <div class="label">Trier & Filtrer</div>
                    <div class="dropdown-content">
                        <div class="dropdown-item">Trier de A à Z</div>
                        <div class="dropdown-item">Trier de Z à A</div>
                        <div class="dropdown-item">Tri personnalisé</div>
                        <div class="separator"></div>
                        <div class="dropdown-item">Filtrer</div>
                        <div class="dropdown-item">Effacer le filtre</div>
                    </div>
                </div>
                <div class="tool">
                    <button class="icon" title="" type="button">↻</button>
                    <div class="label">Recalculer</div>
                </div>
            </div> -->

            <!-- Group 8: Compléments -->
            <!-- <div class="tool-group">
                <div class="group-title">Compléments</div>
                <div class="tool dropdown">
                    <div class="label">Compléments</div>
                    <div class="dropdown-content">
                        <div class="dropdown-item">Gérer les compléments</div>
                        <div class="dropdown-item">Obtenir des compléments</div>
                    </div>
                </div>
                <div class="tool dropdown">
                    <div class="label">Macro</div>
                    <div class="dropdown-content">
                        <div class="dropdown-item">Enregistrer une macro</div>
                        <div class="dropdown-item">Utiliser des macros</div>
                        <div class="dropdown-item">Sécurité des macros</div>
                    </div>
                </div>
            </div> -->
        </div>


        <div class="sheet-tabs" id="sheetTabs">
        </div>
        <div class="excel-container" id="excelContainer">
        </div>
    </div>



    <script>

        const rowSize = 200;
        const colSize = 100;
        let securityFolder;
        let currentFile;
        let currentKeyFile;
        let currentKey;
        let activeSheet = 0;
        let sheets = [];
        function toggleBold() {
            if (selectedCells.length === 0) return;

            selectedCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const sheet = sheets[activeSheet];

                sheet.toggleStyle(row, col, 'bold');
                updateCellDisplay(row, col);
                saveFile();
            });

        }

        function toggleItalic() {
            if (selectedCells.length === 0) return;

            selectedCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const sheet = sheets[activeSheet];

                sheet.toggleStyle(row, col, 'italic');
                updateCellDisplay(row, col);
                saveFile();
            });
        }

        function toggleUpper() {
            selectedCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const sheet = sheets[activeSheet];
                // Update the cell's display
                const value = sheet.getCell(row, col);
                let uppercaseValue = value.toUpperCase();
                if (!sheets[activeSheet].isHidden(row, col)) {
                    cell.textContent = uppercaseValue == value ? value.toLowerCase() : uppercaseValue;
                    sheets[activeSheet].setCell(row, col, uppercaseValue == value ? value.toLowerCase() : uppercaseValue);
                }
            });
        }


        function toggleUnderline() {
            if (selectedCells.length === 0) return;

            selectedCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const sheet = sheets[activeSheet];

                sheet.toggleStyle(row, col, 'underline');
                updateCellDisplay(row, col);
                saveFile();
            });
        }

        function setTextColor(color) {
            if (selectedCells.length === 0) return;

            selectedCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const sheet = sheets[activeSheet];

                sheet.setStyle(row, col, 'color', color);
                updateCellDisplay(row, col);
                saveFile();
            });
        }

        function setBackgroundColor() {
            if (selectedCells.length === 0) return;

            const color = prompt("Enter background color (e.g., 'yellow' or '#ffff00'):");
            if (!color) return;

            selectedCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const sheet = sheets[activeSheet];

                const key = `${row},${col}`;
                const currentCellStyles = sheet.cellStyles.get(key) || {};
                currentCellStyles.backgroundColor = color;
                sheet.cellStyles.set(key, currentCellStyles);

                updateCellDisplay(row, col);
                saveFile();
            });
        }

        function setFontSize() {
            if (selectedCells.length === 0) return;
            let size = document.getElementById('fontSizeInput').value;
            selectedCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const sheet = sheets[activeSheet];

                sheet.setStyle(row, col, 'fontSize', size);
                updateCellDisplay(row, col);
                saveFile();
            });
        }

        function setTextAlign(align) {
            if (selectedCells.length === 0) return;

            selectedCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const sheet = sheets[activeSheet];

                sheet.setStyle(row, col, 'textAlign', align);
                updateCellDisplay(row, col);
                saveFile();
            });
        }

        function setFontFamily(font) {
            if (!font)
                font = prompt("Enter font family (e.g., 'Arial', 'Verdana'):");
            if (!font) return;

            selectedCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const sheet = sheets[activeSheet];

                sheet.setStyle(row, col, 'fontFamily', font);
                updateCellDisplay(row, col);
                saveFile();
            });
        }

        function setNumberFormat(format) {
            selectedCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const sheet = sheets[activeSheet];

                // Apply the format to the cell
                sheet.setStyle(row, col, 'numberFormat', format);

                // Update the cell's display
                const value = sheet.getCell(row, col);
                if (!sheets[activeSheet].isHidden(row, col)) {
                    cell.textContent = formatNumber(value, format);
                    sheets[activeSheet].setCell(row, col, formatNumber(value, format));
                }
            });
        }

        function formatNumber(value, format) {
            if (isNaN(value)) return value; // If not a number, return as-is

            switch (format) {
                case 'general':
                    return value; // No special formatting
                case 'number':
                    return parseFloat(value).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                case 'currency':
                    return parseFloat(value).toLocaleString(undefined, { style: 'currency', currency: 'USD' }); // Default currency
                case 'percentage':
                    return (parseFloat(value) * 100).toFixed(2) + '%';
                case 'date':
                    return new Date(value).toLocaleDateString();
                case 'time':
                    return new Date(value).toLocaleTimeString();
                default:
                    return value; // Unsupported format
            }
        }

        function toggleHiddenCell() {
            if (selectedCells.length === 0) return; // Nothing to toggle if no selection

            selectedCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const sheet = sheets[activeSheet];

                // Toggle the hidden state
                sheet.toggleHidden(row, col);

                // Update the cell content
                if (sheet.isHidden(row, col)) {
                    sheets[activeSheet].setCell(row, col, cell.textContent); // Update the sheet
                    cell.textContent = '***'; // Replace content with *
                    cell.classList.add('hidden-content');
                } else {
                    cell.textContent = sheet.getCell(row, col); // Restore original content
                    cell.classList.remove('hidden-content');
                }
                saveFile();
            });
        }

        function updateCellDisplay(row, col, init = false) {
            const act = sheets[activeSheet];

            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            const { textStyles, cellStyles } = act.getStyles(row, col);

            // Text styles
            if (textStyles && !isEmpty(textStyles)) {

                cell.style.fontWeight = textStyles.bold ? "bold" : "normal";
                cell.style.fontStyle = textStyles.italic ? "italic" : "normal";
                cell.style.textDecoration = textStyles.underline ? "underline" : "none";
                cell.style.color = textStyles.color || "inherit";
                cell.style.fontSize = textStyles.fontSize + "px" || "inherit";
                cell.style.width = textStyles.width + "px" || "inherit";
                cell.style.fontFamily = textStyles.fontFamily || "Arial";
                cell.style.textAlign = textStyles.textAlign || "left";
            }

            // Cell styles
            if (cellStyles && !isEmpty(cellStyles)) {
                cell.style.backgroundColor = cellStyles.backgroundColor || "transparent";
            }

            // Hidden cells
            if (!init) {
                if (act.hiddenCells.has(`${row},${col}`)) {
                    cell.textContent = '***';
                    cell.classList.add('hidden-content');
                } else {
                    cell.textContent = act.getCell(row, col) || '';
                    cell.classList.remove('hidden-content');
                }
            }
        }

        function isEmpty(obj) {
            for (const prop in obj) {
                if (Object.hasOwn(obj, prop)) {
                    return false;
                }
            }

            return true;
        }











        class Sheet {
            constructor(name) {
                this.name = name;
                this.cells = new Map();
                this.richTextStyles = new Map(); // Store text styles (bold, italic, etc.)
                this.cellStyles = new Map(); // Store cell-specific styles like background color
                this.hiddenCells = new Set(); // Track hidden cells
            }

            // Set cell content and optional styles
            setCell(row, col, value, textStyles = null, cellStyles = null) {
                const key = `${row},${col}`;
                this.cells.set(key, value);

                if (textStyles) {
                    this.richTextStyles.set(key, textStyles);
                } else {
                    this.richTextStyles.delete(key);
                }

                if (cellStyles) {
                    this.cellStyles.set(key, cellStyles);
                } else {
                    this.cellStyles.delete(key);
                }
            }

            toggleStyle(row, col, styleKey) {
                const key = `${row},${col}`;
                const currentStyles = this.richTextStyles.get(key) || {};
                currentStyles[styleKey] = !currentStyles[styleKey];
                this.richTextStyles.set(key, currentStyles);
            }

            setStyle(row, col, styleKey, value) {
                const key = `${row},${col}`;
                const currentStyles = this.richTextStyles.get(key) || {};
                currentStyles[styleKey] = value;
                this.richTextStyles.set(key, currentStyles);
            }

            getStyle(row, col, styleKey) {
                const key = `${row},${col}`;
                const styles = this.richTextStyles.get(key) || {};
                return styles[styleKey] || null;
            }

            // Get all styles for a cell
            getStyles(row, col) {
                const key = `${row},${col}`;
                return {
                    textStyles: this.richTextStyles.get(key) || {},
                    cellStyles: this.cellStyles.get(key) || {}
                };
            }

            getRichTextStyles(row, col) {
                const key = `${row},${col}`;
                return this.richTextStyles.get(key) || null;
            }

            isRichText(row, col) {
                const key = `${row},${col}`;
                return this.richTextStyles.has(key);
            }


            removeCell(row, col) {
                const key = `${row},${col}`;
                this.cells.delete(key);
                if (this.hiddenCells.has(key)) {
                    this.hiddenCells.delete(key);
                }
                if (this.richTextStyles.has(key)) {
                    this.richTextStyles.delete(key);
                }
            }

            getCell(row, col) {
                const key = `${row},${col}`;
                return this.cells.get(key) || '';
            }

            toggleHidden(row, col) {
                const key = `${row},${col}`;
                if (this.hiddenCells.has(key)) {
                    this.hiddenCells.delete(key);
                } else {
                    this.hiddenCells.add(key);
                }
            }

            isHidden(row, col) {
                return this.hiddenCells.has(`${row},${col}`);
            }
        }

        function showView(view) {
            document.getElementById('homeView').classList.remove('active');
            document.getElementById('editorView').classList.remove('active');
            document.getElementById(`${view}View`).classList.add('active');

            if (view === 'editor' && sheets.length === 0) {
                initializeEditor();
            }
        }

        async function scanUSB() {
            try {
                const dirHandle = await window.showDirectoryPicker();
                searchSecureKeys(dirHandle);
            } catch (error) {
                console.error('Error accessing USB:', error);
                alert('Error accessing device');
            }
        }

        async function searchSecureKeys(dirHandle) {
            try {
                for await (const entry of dirHandle.values()) {
                    if (entry.kind === 'directory' && entry.name === 'securekeys') {
                        // Found securekeys directory
                        securityFolder = entry;
                        return;
                    }
                }
                alert('SecureKeys folder not found');
            } catch (error) {
                console.error('Error searching for securekeys:', error);
                alert('Error searching device');
            }
        }

        async function createNewSecureFile() {
            try {
                // Generate random key (32 bytes = 256 bits for AES-256)
                const key = new Uint8Array(32);
                crypto.getRandomValues(key);

                // Convert to hex string for storage
                const keyHex = Array.from(key)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');

                currentKey = keyHex;
                sheets = [new Sheet('Sheet1')];
                hiddenCells = new Set();
                currentFile = undefined;
                currentKeyFile = undefined;

                activeSheet = 0;
                saveFile();
                showView('editor');
                renderSheet();
            } catch (error) {
                console.error('Error creating secure file:', error);
                alert('Error creating secure file');
            }
        }

        async function openSecureFile() {
            try {
                // First, select the .securefile
                const [fileHandle] = await window.showOpenFilePicker({
                    types: [{
                        description: 'Secure Files',
                        accept: {
                            'application/securefile': ['.securefile']
                        }
                    }]
                });

                let kfile;
                let keyExists = false;
                // search in securityFolder FileSystemDirectoryHandle AsyncIterator {}

                if (securityFolder) {
                    // Using for await...of to iterate through entries
                    for await (const [name, handle] of securityFolder.entries()) {

                        if (name === fileHandle.name.replace('.securefile', '.securekey')) {
                            keyExists = true;
                            kfile = handle;
                            break;
                        }
                    }
                }

                if (!keyExists) {
                    // Then, select the corresponding .securekey file
                    const [keyF] = await window.showOpenFilePicker({
                        types: [{
                            description: 'Secure Key Files',
                            accept: {
                                'application/securekey': ['.securekey']
                            }
                        }]
                    });
                    kfile = keyF;
                }

                // Read the key file
                const keyFile = await kfile.getFile();
                const keyContent = await keyFile.text();
                // Read the key file
                const encryptedFile = await fileHandle.getFile();
                const encryptedContent = await encryptedFile.text();


                currentKeyFile = kfile;
                currentKey = keyContent;
                currentFile = fileHandle;

                if (document.getElementById("masterPassword").value != "") {

                    let newk = Array.from(document.getElementById("masterPassword").value)
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('')
                    currentKey = decryptContent(currentKey, newk);
                }
                const decryptedContent = decryptContent(encryptedContent, currentKey);

                // Parse file content and create sheets
                parseFileContent(decryptedContent);

                showView('editor');
                renderSheet();
            } catch (error) {
                alert('Error opening file');
            }
        }

        async function saveFile() {
            try {
                let fileHandle;
                if (!currentFile) {
                    fileHandle = await window.showSaveFilePicker({
                        types: [{
                            description: 'Secure Files',
                            accept: { 'application/securefile': ['.securefile'] }
                        }]
                    });
                    currentFile = fileHandle;
                } else {
                    fileHandle = currentFile;
                }

                if (!currentKeyFile) {
                    const key = new Uint8Array(32);
                    crypto.getRandomValues(key);
                    currentKey = Array.from(key).map(b => b.toString(16).padStart(2, '0')).join('');

                    let kf = await window.showSaveFilePicker({
                        types: [{
                            description: 'Secure Files',
                            accept: { 'application/securefile': ['.securekey'] }
                        }]
                    });
                    currentKeyFile = kf;
                    let encryptedKey = currentKey;

                    if (document.getElementById("masterPassword").value != "") {

                        let newk = Array.from(document.getElementById("masterPassword").value)
                            .map(b => b.toString(16).padStart(2, '0'))
                            .join('')
                        encryptedKey = encryptContent(encryptedKey, newk);
                    }

                    const fkw = await currentKeyFile.createWritable();
                    await fkw.write(encryptedKey);
                    await fkw.close();
                }

                let content = '';
                sheets.forEach(sheet => {
                    content += `_filename_sheet_${sheet.name}\n`;
                    sheet.cells.forEach((value, key) => {
                        const [row, col] = key.split(',');
                        if (value === '') {
                            sheet.removeCell(row, col);
                            return;
                        }

                        let cellContent = value;
                        if (sheet.isHidden(row, col)) {
                            value = `pwd(${cellContent})`;
                        }

                        if (sheet.isRichText(row, col) || sheet.cellStyles.get(key)) {

                            const styles = {
                                text: value,
                                textStyles: sheet.getRichTextStyles(row, col),
                                cellStyles: sheet.cellStyles.get(key)
                            };
                            content += `${JSON.stringify(styles)}!,!${col}!,!${row}\n`;
                        } else {
                            content += `${value}!,!${col}!,!${row}\n`;
                        }


                    });
                });

                const encryptedContent = encryptContent(content, currentKey);

                const fileWritable = await fileHandle.createWritable();
                await fileWritable.write(encryptedContent);
                await fileWritable.close();
            } catch (error) {
                console.error('Error saving file:', error);
            }
        }


        // Encryption functions
        function encryptContent(content, keyHex) {
            try {
                // Derive a key using SHA-512
                const key = CryptoJS.SHA512(keyHex);

                // Generate a random IV
                const iv = CryptoJS.lib.WordArray.random(16);

                // Encrypt the content
                const encrypted = CryptoJS.AES.encrypt(content, key, {
                    iv: iv,
                    mode: CryptoJS.mode.CBC,
                    padding: CryptoJS.pad.Pkcs7
                });

                // Combine IV and encrypted content
                return iv.toString() + encrypted.toString();
            } catch (error) {
                console.error('Encryption error:', error);
                throw new Error('Encryption failed');
            }
        }

        function decryptContent(encryptedContent, keyHex) {
            try {
                // Derive the key using SHA-512
                const key = CryptoJS.SHA512(keyHex);

                // Extract IV and encrypted data
                const iv = CryptoJS.enc.Hex.parse(encryptedContent.slice(0, 32));
                const encrypted = encryptedContent.slice(32);

                // Decrypt the content
                const decrypted = CryptoJS.AES.decrypt(encrypted, key, {
                    iv: iv,
                    mode: CryptoJS.mode.CBC,
                    padding: CryptoJS.pad.Pkcs7
                });

                return decrypted.toString(CryptoJS.enc.Utf8);
            } catch (error) {
                alert('Invalid password, verify if master password is correct');
            }
        }

        // Add this utility function
        async function findSecureKeyFile(dirHandle, fileName) {
            try {
                const entries = await dirHandle.values();
                for await (const entry of entries) {
                    if (entry.kind === 'file' && entry.name === fileName) {
                        return entry;
                    } else if (entry.kind === 'directory') {
                        const result = await findSecureKeyFile(entry, fileName);
                        if (result) return result;
                    }
                }
            } catch (error) {
                console.error('Error searching for key file:', error);
            }
            return null;
        }

        function parseFileContent(content) {
            sheets = [];
            const lines = content.split('\n');
            let currentSheet = null;
            for (const line of lines) {
                if (line.startsWith('_filename_sheet_')) {
                    const sheetName = line.split('_filename_sheet_')[1].trim();
                    currentSheet = new Sheet(sheetName);
                    sheets.push(currentSheet);
                } else if (line.trim() && currentSheet) {
                    const [value, col, row] = line.split('!,!');
                    let cellContent = value;

                    // Check for rich text
                    if (value.startsWith('{') && value.endsWith('}')) {
                        try {
                            const parsedStyles = JSON.parse(value);
                            let text = parsedStyles.text;
                            if (text.startsWith('pwd(') && value.endsWith(')')) {
                                text = text.slice(4, -1);
                                currentSheet.toggleHidden(parseInt(row), parseInt(col));
                            }

                            currentSheet.setCell(parseInt(row), parseInt(col), text, parsedStyles.textStyles, parsedStyles.cellStyles);
                        } catch (e) {
                            console.error("Failed to parse cell styles:", e);
                        }
                    } else if (value.startsWith('pwd(') && value.endsWith(')')) {
                        currentSheet.setCell(parseInt(row), parseInt(col), value.slice(4, -1));
                        currentSheet.toggleHidden(parseInt(row), parseInt(col));
                    } else {
                        currentSheet.setCell(parseInt(row), parseInt(col), value);
                    }
                }
            }

            if (sheets.length === 0) {
                sheets.push(new Sheet('Sheet1'));
            }
        }


        function initializeEditor() {
            sheets = [new Sheet('Sheet1')];
            renderSheet();
        }

        function renderSheet() {
            renderSheetTabs();
            renderGrid();
        }

        function renderSheetTabs() {
            const tabsContainer = document.getElementById('sheetTabs');
            tabsContainer.innerHTML = '';

            sheets.forEach((sheet, index) => {
                const tab = document.createElement('div');
                tab.className = `sheet-tab ${index === activeSheet ? 'active' : ''}`;
                tab.textContent = sheet.name;
                tab.onclick = () => switchSheet(index);
                tabsContainer.appendChild(tab);
            });
        }


        let selectedCells = [];

        function renderGrid() {
            const container = document.getElementById('excelContainer');
            container.innerHTML = '';

            const grid = document.createElement('div');
            grid.className = 'excel-grid';

            // Add corner cell
            const cornerCell = document.createElement('div');
            cornerCell.className = 'cell header';
            grid.appendChild(cornerCell);

            // Add column headers
            for (let col = 0; col < 100; col++) {
                const header = document.createElement('div');
                header.className = 'cell header';
                header.textContent = String.fromCharCode(65 + (col % 26));
                grid.appendChild(header);
            }


            const sheet = sheets[activeSheet];

            // Add rows
            for (let row = 0; row < rowSize; row++) {
                // Add row header
                const rowHeader = document.createElement('div');
                rowHeader.className = 'cell row-header';
                rowHeader.textContent = row + 1;
                grid.appendChild(rowHeader);

                // Add cells
                for (let col = 0; col < colSize; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.contentEditable = true;
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    const isHidden = sheet.isHidden(row, col);
                    const value = sheet.getCell(row, col);

                    // Show masked or actual value
                    cell.textContent = isHidden ? '***' : value;

                    if (isHidden) {
                        cell.classList.add('hidden-content');
                    }

                    // Attach selection events
                    cell.addEventListener('mousedown', (event) => startSelection(event, cell));
                    cell.addEventListener('mouseover', (event) => continueSelection(event, cell));
                    cell.addEventListener('mouseup', endSelection);
                    cell.addEventListener('keydown', (event) => handleCtrl(event));
                    cell.addEventListener('keyup', (event) => handleCellInput(event));

                    grid.appendChild(cell);
                }
            }

            container.appendChild(grid);
            sheet.richTextStyles.forEach((element, key) => {
                //get element row and col
                arr = key.split(",");
                let row = parseInt(arr[0]);
                let col = parseInt(arr[1]);
                //update display
                updateCellDisplay(row, col, true);
            });
        }



        let isSelecting = false;
        let selectionStart = null;

        function startSelection(event, cell) {
            selectedCells.forEach(cell => cell.classList.remove('selected'));
            selectedCells = [];

            isSelecting = true;
            selectionStart = cell;

            document.getElementById("fontSizeInput").value = cell.style.fontSize;
            addToSelection(cell);
        }

        function continueSelection(event, cell) {
            if (!isSelecting) return;

            // Clear previous selection
            selectedCells.forEach(cell => cell.classList.remove('selected'));
            selectedCells = [];

            // Get start and end coordinates
            const startRow = parseInt(selectionStart.dataset.row);
            const startCol = parseInt(selectionStart.dataset.col);
            const endRow = parseInt(cell.dataset.row);
            const endCol = parseInt(cell.dataset.col);

            // Calculate selection rectangle
            const minRow = Math.min(startRow, endRow);
            const maxRow = Math.max(startRow, endRow);
            const minCol = Math.min(startCol, endCol);
            const maxCol = Math.max(startCol, endCol);

            // Select all cells in the rectangle
            for (let row = minRow; row <= maxRow; row++) {
                for (let col = minCol; col <= maxCol; col++) {
                    const currentCell = document.querySelector(
                        `.cell[data-row="${row}"][data-col="${col}"]`
                    );
                    if (currentCell) {
                        addToSelection(currentCell);
                    }
                }
            }
        }

        function endSelection() {
            isSelecting = false;
            selectionStart = null;
        }

        function addToSelection(cell) {
            if (!cell.classList.contains('selected')) {
                cell.classList.add('selected');
                selectedCells.push(cell);
            }
        }

        function switchSheet(index) {
            activeSheet = index;
            renderSheet();
        }

        let isCtrlPressed = false;
        function handleCtrl(event) {
            if (event.key === "Control") {
                isCtrlPressed = true;
            }
        }

        function handleCellInput(event) {

            //return if ctrl key or shift key is pressed
            if (event.key === "Control") {
                isCtrlPressed = false;
                return;
            }
            if (isCtrlPressed && (event.key === 'c' || event.key === 'C') || event.key === "CapsLock" || event.shiftKey) return;
            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            if (cell.textContent === '')
                sheets[activeSheet].removeCell(row, col);
            else {
                if (sheets[activeSheet].isHidden(row, col)) {
                    alert("This cell is hidden, Toggle the visibility to edit");
                    cell.textContent = "***";
                    return;
                }
                if (isCtrlPressed && (event.key === "i" || event.key === "I")) {
                    toggleItalic();
                }
                else if (isCtrlPressed && (event.key === "b" || event.key === "B")) {
                    toggleBold();
                }
                else if (isCtrlPressed && (event.key === "u" || event.key === "U")) {
                    toggleUnderline();
                } else {
                    sheets[activeSheet].setCell(row, col, cell.textContent);
                    saveFile(); // Auto-save after editing a cell
                }
            }
        }

        function addNewSheet() {
            const name = `Sheet${sheets.length + 1}`;
            sheets.push(new Sheet(name));
            activeSheet = sheets.length - 1;
            renderSheet();
            saveFile(); // Auto-save after adding a sheet
        }

        function renameSheet() {
            const newName = prompt("Enter a new name for the sheet:");
            if (newName && newName.trim()) {
                sheets[activeSheet].name = newName.trim();
                renderSheetTabs();
                saveFile(); // Auto-save after renaming
            }
        }

        function removeSheet() {
            const yes = prompt("Are you sure, this is not reversible, type 'yes' to confirm");
            if (yes.trim() === 'yes') {
                sheets.splice(activeSheet, 1);
                if (activeSheet >= sheets.length) {
                    activeSheet = sheets.length - 1;
                }
                renderSheet();
                renderSheetTabs();
                saveFile(); // Auto-save after removing a sheet
            }
        }

        document.addEventListener('paste', (event) => {
            handlePaste(event);
        })

        function handlePaste(event) {
            event.preventDefault();
            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            const text = event.clipboardData.getData('text');
            const rows = text.split('\n');

            rows.forEach((rowText, rowOffset) => {
                const cells = rowText.split('\t');
                cells.forEach((cellText, colOffset) => {
                    const targetRow = row + rowOffset;
                    const targetCol = col + colOffset;
                    sheets[activeSheet].setCell(targetRow, targetCol, cellText);
                });
            });

            renderSheet();
        }

        document.addEventListener('copy', (event) => {
            if (selectedCells.length === 0) return;

            let content = '';
            const selectedData = {};

            // Collect selected cells
            selectedCells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const value = sheets[activeSheet].getCell(row, col);

                if (!selectedData[row]) selectedData[row] = {};

                selectedData[row][col] = sheets[activeSheet].isHidden(row, col) ? value : cell.textContent;
            });

            // Format selected data into rows and columns
            const rows = Object.keys(selectedData).sort((a, b) => a - b);
            rows.forEach(row => {
                const cols = Object.keys(selectedData[row]).sort((a, b) => a - b);
                const rowData = cols.map(col => selectedData[row][col]);
                content += rowData.join('\t') + '\n';
            });

            // Set copied content
            event.clipboardData.setData('text/plain', content.trim());
            event.preventDefault();
        });



        // Initialize with home view
        showView('home');
    </script>
</body>

</html>